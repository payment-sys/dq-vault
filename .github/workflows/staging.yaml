name: Staging Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*-beta.*'

permissions:
  contents: write
  packages: write

env:
  GO_VERSION: '1.24'
  REGISTRY: registry.digitalocean.com
  IMAGE_NAME: cpg-staging/dq-vault

jobs:
  # Test Code Phase
  test-code:
    name: Test Code
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v8
        with:
          version: latest
          args: --timeout=5m

      - name: Lint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile

      - name: Run tests with coverage and race detection
        run: make test-coverage-race

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload coverage to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.out
            coverage.html

      - name: Run benchmark tests
        run: make test-bench

      - name: Upload benchmark results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: |
            benchmark.out

  # Build Phase
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test-code
    timeout-minutes: 20
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DigitalOcean Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}-staging
            type=raw,value=staging-latest

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          platforms: linux/amd64

  # Release Latest Phase
  release-latest:
    name: Release Latest Staging
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to DigitalOcean Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Tag as staging-latest
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: .

      - name: Create preliminary release
        run: |
          echo "Preliminary release created - final release will be created after vault initialization"

  # Deploy Phase
  deploy:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 30
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.12.0

      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace dq-vault-staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Create image pull secret
        run: |
          # Delete existing secret if it exists
          kubectl delete secret regcred --namespace=dq-vault-staging --ignore-not-found=true
          
          # Create new secret
          kubectl create secret docker-registry regcred \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ secrets.DOCKER_USERNAME }} \
            --docker-password=${{ secrets.DOCKER_PASSWORD }} \
            --namespace=dq-vault-staging

      - name: Force clean deployment
        run: |
          # Delete existing deployment to force recreation
          kubectl delete deployment dq-vault-staging --namespace=dq-vault-staging --ignore-not-found=true
          
          # Wait for deployment to be completely removed
          kubectl wait --for=delete deployment/dq-vault-staging --namespace=dq-vault-staging --timeout=300s || true
          
          # Delete existing pods to ensure fresh start
          kubectl delete pods -l app.kubernetes.io/name=dq-vault --namespace=dq-vault-staging --ignore-not-found=true
          
          # Delete existing PVC to avoid immutability issues
          kubectl delete pvc dq-vault-staging-data --namespace=dq-vault-staging --ignore-not-found=true
          
          echo "âœ… Cleaned up existing deployment and PVC"

      - name: Deploy with Helm
        run: |
          # Generate unique deployment timestamp for forced updates
          DEPLOY_TIMESTAMP=$(date +%s)
          
          helm upgrade --install dq-vault-staging ./.charts/dq-vault \
            --namespace dq-vault-staging \
            --wait --atomic --timeout=15m \
            --force \
            --values ./.charts/dq-vault/values.yaml \
            --values ./.charts/dq-vault/values-staging.yaml \
            --set image.tag=${{ needs.build.outputs.image-tag }} \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set podAnnotations.deployTimestamp="\"$DEPLOY_TIMESTAMP\"" \
            --set podAnnotations.buildId="\"${{ github.run_id }}\"" \
            --set podAnnotations.commitSha="\"${{ github.sha }}\""

      - name: Verify deployment
        run: |
          echo "Waiting for deployment to be ready..."
          
          # First check if deployment was created successfully
          if ! kubectl get deployment dq-vault-staging -n dq-vault-staging &>/dev/null; then
            echo "âŒ Deployment was not created successfully"
            echo "Available deployments:"
            kubectl get deployments -n dq-vault-staging
            exit 1
          fi
          
          # Wait for deployment to be available
          if ! kubectl wait --for=condition=available --timeout=600s deployment/dq-vault-staging -n dq-vault-staging; then
            echo "âŒ Deployment failed to become available within 10 minutes"
            echo "ğŸ” Troubleshooting deployment issues..."
            
            # Show deployment status
            echo "Deployment status:"
            kubectl get deployment dq-vault-staging -n dq-vault-staging -o wide
            kubectl describe deployment dq-vault-staging -n dq-vault-staging
            
            # Show replica set status
            echo "ReplicaSet status:"
            kubectl get rs -n dq-vault-staging -l app.kubernetes.io/name=dq-vault
            kubectl describe rs -n dq-vault-staging -l app.kubernetes.io/name=dq-vault
            
            # Show pod status with detailed information
            echo "Pod status:"
            kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o wide
            
            # Check if there are any pods
            POD_COUNT=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault --no-headers 2>/dev/null | wc -l)
            if [ "$POD_COUNT" -eq 0 ]; then
              echo "âŒ No pods found - this indicates a serious deployment issue"
              echo "Checking namespace events:"
              kubectl get events -n dq-vault-staging --sort-by='.lastTimestamp' | tail -30
              exit 1
            fi
            
            # Get the first pod for detailed diagnosis
            POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
            if [ -n "$POD_NAME" ]; then
              echo "Detailed pod analysis for: $POD_NAME"
              kubectl describe pod "$POD_NAME" -n dq-vault-staging
              
              # Check pod logs if available
              echo "Pod logs:"
              kubectl logs "$POD_NAME" -n dq-vault-staging --tail=100 || echo "No logs available yet"
              
              # Check previous logs if pod restarted
              echo "Previous pod logs (if any):"
              kubectl logs "$POD_NAME" -n dq-vault-staging --previous --tail=50 || echo "No previous logs"
            fi
            
            # Check PVC status
            echo "PVC status:"
            kubectl get pvc -n dq-vault-staging
            kubectl describe pvc -n dq-vault-staging
            
            # Check node resources
            echo "Node resources:"
            kubectl top nodes || echo "Metrics not available"
            kubectl describe nodes || echo "Cannot describe nodes"
            
            # Check recent events
            echo "Recent cluster events:"
            kubectl get events -n dq-vault-staging --sort-by='.lastTimestamp' | tail -20
            
            exit 1
          fi
          
          echo "âœ… Deployment is available"
          
          echo "Checking pod status..."
          kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault
          
          echo "Checking service status..."
          kubectl get svc -n dq-vault-staging -l app.kubernetes.io/name=dq-vault

      - name: Basic deployment check
        run: |
          echo "Performing basic deployment check..."
          
          # Just check that resources were created successfully
          echo "Checking deployment exists..."
          kubectl get deployment dq-vault-staging -n dq-vault-staging
          
          echo "Checking service exists..."
          kubectl get svc dq-vault-staging -n dq-vault-staging
          
          echo "Checking pod status..."
          kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault
          
          echo "âœ… Basic deployment check completed - detailed verification will happen in next stage"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… DQ Vault staging deployment completed successfully!"
            echo "Release: ${{ github.ref_name }}"
            echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
            echo "Environment: dq-vault-staging"
            echo "Namespace: dq-vault-staging"
          else
            echo "âŒ DQ Vault staging deployment failed!"
            exit 1
          fi

  # Post-deployment verification
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy
    timeout-minutes: 15
    steps:
      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          
          # Test basic connectivity
          kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging &
          sleep 15
          
          # Test Vault health endpoint with proper parameters
          if curl -s -f "http://localhost:8200/v1/sys/health?standbyok=true&uninitcode=204&sealedcode=204"; then
            echo "âœ… Vault health endpoint accessible"
          else
            echo "âŒ Vault health endpoint failed"
            exit 1
          fi
          
          # Test Vault initialization status (should always work)
          if curl -s http://localhost:8200/v1/sys/init | grep -q '"initialized"'; then
            echo "âœ… Vault initialization status check passed"
          else
            echo "âŒ Vault initialization status check failed"
            exit 1
          fi
          
          # Check if pods are ready
          if kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault --no-headers | grep -q "1/1.*Running"; then
            echo "âœ… Pod readiness check passed"
          else
            echo "âŒ Pod readiness check failed"
            kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault
            exit 1
          fi
          
          # Cleanup
          pkill -f "kubectl port-forward" || true
          
          echo "âœ… All smoke tests passed!"

      - name: Check resource usage
        run: |
          echo "Checking resource usage..."
          kubectl top pods -n dq-vault-staging || echo "Metrics not available"
          kubectl get events -n dq-vault-staging --sort-by='.lastTimestamp' | tail -20

      - name: Generate deployment report
        run: |
          echo "## DQ Vault Staging Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "- **Release**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: dq-vault-staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: dq-vault-staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Supported Cryptocurrencies" >> $GITHUB_STEP_SUMMARY
          echo "- Bitcoin (BTC), Ethereum (ETH), Litecoin (LTC)" >> $GITHUB_STEP_SUMMARY
          echo "- Dogecoin (DOGE), Ripple (XRP), Stellar (XLM)" >> $GITHUB_STEP_SUMMARY
          echo "- Solana (SOL), Bitshares (BTS), Tron (TRX)" >> $GITHUB_STEP_SUMMARY

  # Vault Initialization Phase
  vault-init:
    name: Initialize Vault
    runs-on: ubuntu-latest
    needs: verify-deployment
    timeout-minutes: 15
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    steps:
      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Check if Vault is already initialized
        id: vault-status
        run: |
          echo "Checking Vault initialization status..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          echo "Pod name: $POD_NAME"
          
          # Check initialization status
          INIT_STATUS=$(kubectl exec -n dq-vault-staging $POD_NAME -- vault status -format=json | jq -r '.initialized')
          echo "Vault initialized: $INIT_STATUS"
          
          if [ "$INIT_STATUS" = "true" ]; then
            echo "vault-initialized=true" >> $GITHUB_OUTPUT
            echo "âœ… Vault is already initialized"
          else
            echo "vault-initialized=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  Vault is not initialized - will initialize now"
          fi

      - name: Initialize Vault
        id: vault-init
        if: steps.vault-status.outputs.vault-initialized == 'false'
        run: |
          echo "Initializing Vault..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          
          # Initialize Vault and capture output
          INIT_OUTPUT=$(kubectl exec -n dq-vault-staging $POD_NAME -- vault operator init -format=json)
          
          # Parse the JSON output
          UNSEAL_KEYS=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[]')
          ROOT_TOKEN=$(echo "$INIT_OUTPUT" | jq -r '.root_token')
          
          # Store in environment variables (visible for staging)
          echo "UNSEAL_KEY_1=$(echo "$UNSEAL_KEYS" | sed -n '1p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_2=$(echo "$UNSEAL_KEYS" | sed -n '2p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_3=$(echo "$UNSEAL_KEYS" | sed -n '3p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_4=$(echo "$UNSEAL_KEYS" | sed -n '4p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_5=$(echo "$UNSEAL_KEYS" | sed -n '5p')" >> $GITHUB_ENV
          echo "ROOT_TOKEN=$ROOT_TOKEN" >> $GITHUB_ENV
          
          # Note: Values are NOT masked for staging environment visibility
          
          echo "âœ… Vault initialized successfully"
          echo "vault-init-success=true" >> $GITHUB_OUTPUT

      - name: Unseal Vault
        if: steps.vault-init.outputs.vault-init-success == 'true'
        run: |
          echo "Unsealing Vault..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          
          # Unseal with first 3 keys
          kubectl exec -n dq-vault-staging $POD_NAME -- vault operator unseal "$UNSEAL_KEY_1"
          kubectl exec -n dq-vault-staging $POD_NAME -- vault operator unseal "$UNSEAL_KEY_2"
          kubectl exec -n dq-vault-staging $POD_NAME -- vault operator unseal "$UNSEAL_KEY_3"
          
          # Verify vault is unsealed
          SEALED_STATUS=$(kubectl exec -n dq-vault-staging $POD_NAME -- vault status -format=json | jq -r '.sealed')
          
          if [ "$SEALED_STATUS" = "false" ]; then
            echo "âœ… Vault unsealed successfully"
          else
            echo "âŒ Failed to unseal Vault"
            exit 1
          fi

      - name: Print Vault credentials
        if: steps.vault-init.outputs.vault-init-success == 'true'
        run: |
          echo "ğŸ” DQ Vault Staging Environment Initialized"
          echo "============================================="
          echo ""
          echo "Environment: dq-vault-staging"
          echo "Release: ${{ github.ref_name }}"
          echo "Timestamp: $(date -u)"
          echo "Status: âœ… Successfully initialized and unsealed"
          echo ""
          echo "ğŸ”‘ UNSEAL KEYS:"
          echo "==============="
          echo "Key 1: $UNSEAL_KEY_1"
          echo "Key 2: $UNSEAL_KEY_2"
          echo "Key 3: $UNSEAL_KEY_3"
          echo "Key 4: $UNSEAL_KEY_4"
          echo "Key 5: $UNSEAL_KEY_5"
          echo ""
          echo "ğŸ¯ ROOT TOKEN:"
          echo "=============="
          echo "$ROOT_TOKEN"
          echo ""
          echo "âš ï¸  SECURITY NOTES:"
          echo "==================="
          echo "â€¢ These credentials provide FULL ACCESS to the Vault"
          echo "â€¢ Store them securely and NEVER commit to version control"
          echo "â€¢ Use unseal keys to recover if Vault gets sealed"
          echo "â€¢ Root token should be used only for initial setup"
          echo "â€¢ Create limited tokens for day-to-day operations"
          echo ""
          echo "ğŸš€ NEXT STEPS:"
          echo "=============="
          echo "â€¢ Access Vault: kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging"
          echo "â€¢ Test health: curl http://localhost:8200/v1/sys/health"
          echo "â€¢ Follow setup guide in repository"
          echo ""
          echo "âœ… Vault credentials printed above"

      - name: Install DQ Plugin
        if: steps.vault-init.outputs.vault-init-success == 'true'
        run: |
          echo "Installing DQ plugin..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          
          # Set the root token for plugin installation
          kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "export VAULT_TOKEN=$ROOT_TOKEN && vault secrets disable /dq" || echo "No existing dq secrets to disable"
          
          # Calculate SHA256 of the plugin binary
          echo "Calculating plugin SHA256..."
          PLUGIN_SHA256=$(kubectl exec -n dq-vault-staging $POD_NAME -- sh -c 'sha256sum "/vault/plugins/dq-vault" | cut -d" " -f1')
          echo "Plugin SHA256: $PLUGIN_SHA256"
          
          # Register the plugin in Vault's catalog
          echo "Registering DQ plugin in catalog..."
          kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "export VAULT_TOKEN=$ROOT_TOKEN && vault write sys/plugins/catalog/dq sha_256=\"$PLUGIN_SHA256\" command=\"dq-vault\""
          
          # Enable the plugin as a secrets engine
          echo "Enabling DQ plugin as secrets engine..."
          kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "export VAULT_TOKEN=$ROOT_TOKEN && vault secrets enable -path=\"dq\" -plugin-name=\"dq\" plugin"
          
          # Create policy for DQ plugin
          echo "Creating DQ policy..."
          kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "export VAULT_TOKEN=$ROOT_TOKEN && echo 'path \"dq/*\" { capabilities = [\"read\", \"update\"] }' > /tmp/dq-policy.hcl"
          kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "export VAULT_TOKEN=$ROOT_TOKEN && vault policy write dq-policy /tmp/dq-policy.hcl"
          
          # Create token with DQ policy
          echo "Creating DQ token..."
          DQ_TOKEN_OUTPUT=$(kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "export VAULT_TOKEN=$ROOT_TOKEN && vault token create -policy=dq-policy -renewable=false -no-default-policy")
          DQ_TOKEN=$(echo "$DQ_TOKEN_OUTPUT" | grep "token " | head -1 | awk '{print $2}')
          
          echo "DQ_TOKEN=$DQ_TOKEN" >> $GITHUB_ENV
          
          echo "âœ… DQ plugin installed successfully"
          echo ""
          echo "ğŸ”§ DQ PLUGIN DETAILS:"
          echo "====================="
          echo "Plugin SHA256: $PLUGIN_SHA256"
          echo "DQ Token: $DQ_TOKEN"
          echo ""
          echo "ğŸš€ PLUGIN USAGE:"
          echo "================"
          echo "â€¢ Register user: vault write dq/register username=\"root\" mnemonic=\"your-mnemonic\""
          echo "â€¢ Create address: vault write dq/address uuid=\"user-uuid\" path=\"m/44'/60'/0'/0/0\" coinType=60"
          echo "â€¢ Sign transaction: vault write dq/signature uuid=\"user-uuid\" path=\"m/44'/60'/0'/0/0\" payload=\"{...}\" coinType=60"

      - name: Register User with Mnemonic
        if: steps.vault-init.outputs.vault-init-success == 'true'
        run: |
          echo "Registering user with mnemonic..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          
          # Install curl in the pod if not available
          kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "apk add curl" || echo "curl already installed"
          
          # Register user with mnemonic using the DQ token
          echo "Registering root user with mnemonic..."
          REGISTER_OUTPUT=$(kubectl exec -n dq-vault-staging $POD_NAME -- sh -c "curl -s -k --location 'http://127.0.0.1:8200/v1/dq/register' --header 'X-Vault-Token: $DQ_TOKEN' --header 'Content-Type: application/json' --data '{\"username\": \"root\", \"mnemonic\": \"${{ secrets.MNEMONIC }}\"}'")
          
          # Extract UUID from the response
          USER_UUID=$(echo "$REGISTER_OUTPUT" | grep -o '"uuid":"[^"]*"' | cut -d'"' -f4)
          
          if [ -n "$USER_UUID" ]; then
            echo "USER_UUID=$USER_UUID" >> $GITHUB_ENV
            echo "âœ… User registered successfully"
            echo ""
            echo "ğŸ‘¤ USER REGISTRATION DETAILS:"
            echo "============================="
            echo "Username: root"
            echo "UUID: $USER_UUID"
            echo ""
            echo "ğŸ”§ READY TO USE COMMANDS:"
            echo "========================="
            echo "â€¢ Create BTC address: vault write dq/address uuid=\"$USER_UUID\" path=\"m/44'/0'/0'/0/0\" coinType=0"
            echo "â€¢ Create ETH address: vault write dq/address uuid=\"$USER_UUID\" path=\"m/44'/60'/0'/0/0\" coinType=60"
            echo "â€¢ Create SOL address: vault write dq/address uuid=\"$USER_UUID\" path=\"m/44'/501'/0'\" coinType=501"
            echo ""
            echo "ğŸ¯ EXAMPLE USAGE:"
            echo "================="
            echo "kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging"
            echo "export VAULT_TOKEN=$DQ_TOKEN"
            echo "vault write dq/address uuid=\"$USER_UUID\" path=\"m/44'/60'/0'/0/0\" coinType=60"
          else
            echo "âŒ Failed to register user"
            echo "Registration response: $REGISTER_OUTPUT"
            exit 1
          fi

      - name: Create Credentials File
        if: steps.vault-init.outputs.vault-init-success == 'true'
        run: |
          echo "Creating credentials file for GitHub release..."
          
          # Create credentials file
          cat > dq-vault-staging-credentials.txt << EOF
          DQ Vault Staging Environment Credentials
          ========================================
          
          Release: ${{ github.ref_name }}
          Environment: dq-vault-staging
          Timestamp: $(date -u)
          
          UNSEAL KEYS:
          ============
          Key 1: $UNSEAL_KEY_1
          Key 2: $UNSEAL_KEY_2
          Key 3: $UNSEAL_KEY_3
          Key 4: $UNSEAL_KEY_4
          Key 5: $UNSEAL_KEY_5
          
          ROOT TOKEN:
          ===========
          $ROOT_TOKEN
          
          DQ PLUGIN TOKEN:
          ================
          $DQ_TOKEN
          
          USER DETAILS:
          =============
          Username: root
          UUID: $USER_UUID
          
          QUICK START COMMANDS:
          =====================
          # Connect to Vault
          kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging
          export VAULT_TOKEN=$DQ_TOKEN
          
          # Create addresses for different cryptocurrencies
          vault write dq/address uuid="$USER_UUID" path="m/44'/0'/0'/0/0" coinType=0     # Bitcoin
          vault write dq/address uuid="$USER_UUID" path="m/44'/60'/0'/0/0" coinType=60   # Ethereum
          vault write dq/address uuid="$USER_UUID" path="m/44'/2'/0'/0/0" coinType=2     # Litecoin
          vault write dq/address uuid="$USER_UUID" path="m/44'/3'/0'/0/0" coinType=3     # Dogecoin
          vault write dq/address uuid="$USER_UUID" path="m/44'/144'/0'/0/0" coinType=144 # Ripple
          vault write dq/address uuid="$USER_UUID" path="m/44'/148'/0'/0/0" coinType=148 # Stellar
          vault write dq/address uuid="$USER_UUID" path="m/44'/501'/0'" coinType=501     # Solana
          vault write dq/address uuid="$USER_UUID" path="m/44'/19167'/0'/0/0" coinType=19167 # Bitshares
          vault write dq/address uuid="$USER_UUID" path="m/44'/195'/0'/0/0" coinType=195 # Tron
          
          SECURITY NOTES:
          ===============
          â€¢ These credentials provide FULL ACCESS to the Vault
          â€¢ Store them securely and NEVER commit to version control
          â€¢ Use unseal keys to recover if Vault gets sealed
          â€¢ Root token should be used only for initial setup
          â€¢ DQ token is for day-to-day operations
          â€¢ This is a STAGING environment - use appropriate security measures
          
          VAULT UNSEALING:
          ================
          If Vault gets sealed, use these commands to unseal:
          kubectl exec -n dq-vault-staging [pod-name] -- vault operator unseal $UNSEAL_KEY_1
          kubectl exec -n dq-vault-staging [pod-name] -- vault operator unseal $UNSEAL_KEY_2
          kubectl exec -n dq-vault-staging [pod-name] -- vault operator unseal $UNSEAL_KEY_3
          
          SUPPORTED CRYPTOCURRENCIES:
          ===========================
          â€¢ Bitcoin (BTC) - coinType: 0
          â€¢ Ethereum (ETH) - coinType: 60
          â€¢ Litecoin (LTC) - coinType: 2
          â€¢ Dogecoin (DOGE) - coinType: 3
          â€¢ Ripple (XRP) - coinType: 144
          â€¢ Stellar (XLM) - coinType: 148
          â€¢ Solana (SOL) - coinType: 501
          â€¢ Bitshares (BTS) - coinType: 19167
          â€¢ Tron (TRX) - coinType: 195
          EOF
          
          echo "âœ… Credentials file created: dq-vault-staging-credentials.txt"
          
          # Show file content for verification
          echo "ğŸ“„ Credentials file content:"
          cat dq-vault-staging-credentials.txt

      - name: Upload credentials file as artifact
        if: steps.vault-init.outputs.vault-init-success == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: dq-vault-staging-credentials
          path: dq-vault-staging-credentials.txt

      - name: Vault initialization summary
        if: always()
        run: |
          if [ "${{ steps.vault-status.outputs.vault-initialized }}" = "true" ]; then
            echo "â„¹ï¸  Vault was already initialized - no action needed"
          elif [ "${{ steps.vault-init.outputs.vault-init-success }}" = "true" ]; then
            echo "âœ… Vault initialization completed successfully!"
            echo "ğŸ“‹ Credentials printed in workflow logs"
            echo "ğŸ”§ DQ plugin installed and configured"
            echo "ğŸ‘¤ Root user registered with mnemonic"
            echo "ğŸ” Vault is now ready for use"
          else
            echo "âš ï¸  Vault initialization was skipped or failed"
          fi
          
          # Add to GitHub summary
          echo "## Vault Initialization Status" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.vault-status.outputs.vault-initialized }}" = "true" ]; then
            echo "- **Status**: â„¹ï¸ Already initialized" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.vault-init.outputs.vault-init-success }}" = "true" ]; then
            echo "- **Status**: âœ… Successfully initialized" >> $GITHUB_STEP_SUMMARY
            echo "- **Credentials**: ğŸ“‹ Printed in workflow logs" >> $GITHUB_STEP_SUMMARY
            echo "- **DQ Plugin**: ğŸ”§ Installed and configured" >> $GITHUB_STEP_SUMMARY
            echo "- **User Registration**: ğŸ‘¤ Root user registered" >> $GITHUB_STEP_SUMMARY
            echo "- **Unsealed**: âœ… Ready for use" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status**: âš ï¸ Skipped or failed" >> $GITHUB_STEP_SUMMARY
          fi

  # Final Release Creation
  create-final-release:
    name: Create Final Release
    runs-on: ubuntu-latest
    needs: [build, vault-init]
    timeout-minutes: 10
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    steps:
      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: .

      - name: Download benchmark results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results
          path: .

      - name: Download credentials file
        uses: actions/download-artifact@v4
        with:
          name: dq-vault-staging-credentials
          path: .

      - name: Create Complete GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: DQ Vault Staging Release ${{ github.ref_name }}
          body: |
            ## DQ Vault Staging Release ${{ github.ref_name }}
            
            This is a staging release of the DQ Vault cryptocurrency plugin for HashiCorp Vault.
            
            ### ğŸ” Staging Environment Ready
            - **Environment**: dq-vault-staging
            - **Status**: âœ… Deployed and initialized
            - **Plugin**: ğŸ”§ DQ plugin installed and configured
            - **User**: ğŸ‘¤ Root user registered with mnemonic
            - **Docker Image**: `${{ needs.build.outputs.image-tag }}`
            - **Staging Latest**: `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest`
            
            ### ğŸ“„ Credentials File
            Download the `dq-vault-staging-credentials.txt` file attached to this release for:
            - ğŸ”‘ All 5 Vault unseal keys
            - ğŸ¯ Root token (admin access)
            - ğŸ”§ DQ plugin token (limited access)
            - ğŸ‘¤ User UUID for operations
            - ğŸš€ Ready-to-use commands for all supported cryptocurrencies
            
            ### Supported Cryptocurrencies
            - Bitcoin (BTC), Ethereum (ETH), Litecoin (LTC)
            - Dogecoin (DOGE), Ripple (XRP), Stellar (XLM)
            - Solana (SOL), Bitshares (BTS), Tron (TRX)
            
            ### Quick Start
            ```bash
            # Download credentials file and follow the instructions
            # Connect to staging environment
            kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging
            
            # Use the DQ token from credentials file
            export VAULT_TOKEN=[dq-token-from-file]
            
            # Create your first address
            vault write dq/address uuid="[uuid-from-file]" path="m/44'/60'/0'/0/0" coinType=60
            ```
            
            ### Docker Usage
            ```bash
            # Pull the image
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest
            
            # Run with docker-compose
            docker-compose up -d
            ```
            
            ### Security Note
            This is a **STAGING** environment. The credentials file contains sensitive information suitable for development and testing purposes only.
          draft: false
          prerelease: true
          files: |
            dq-vault-staging-credentials.txt
            coverage.html
            benchmark.out
