name: Staging Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*-beta.*'

permissions:
  contents: write
  packages: write

env:
  GO_VERSION: '1.24'
  REGISTRY: registry.digitalocean.com
  IMAGE_NAME: cpg-staging/dq-vault

jobs:
  # Test Code Phase
  test-code:
    name: Test Code
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v8
        with:
          version: latest
          args: --timeout=5m

      - name: Lint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile

      - name: Run tests with coverage and race detection
        run: make test-coverage-race

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload coverage to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.out
            coverage.html

      - name: Run benchmark tests
        run: make test-bench

      - name: Upload benchmark results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: |
            benchmark.out

  # Build Phase
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test-code
    timeout-minutes: 20
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DigitalOcean Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}-staging
            type=raw,value=staging-latest

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          platforms: linux/amd64

  # Release Latest Phase
  release-latest:
    name: Release Latest Staging
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to DigitalOcean Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Tag as staging-latest
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: .

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: DQ Vault Staging Release ${{ github.ref_name }}
          body: |
            ## DQ Vault Staging Release ${{ github.ref_name }}
            
            This is a staging release of the DQ Vault cryptocurrency plugin for HashiCorp Vault.
            
            ### Docker Image
            - Tag: `${{ needs.build.outputs.image-tag }}`
            - Staging Latest: `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest`
            - Digest: `${{ needs.build.outputs.image-digest }}`
            
            ### Supported Cryptocurrencies
            - Bitcoin (BTC)
            - Ethereum (ETH)
            - Litecoin (LTC)
            - Dogecoin (DOGE)
            - Ripple (XRP)
            - Stellar (XLM)
            - Solana (SOL)
            - Bitshares (BTS)
            - Tron (TRX)
            
            ### Artifacts
            - Coverage reports and benchmark results are available in the workflow artifacts
            
            ### Deployment
            This release will be automatically deployed to the staging environment.
            
            ### Usage
            ```bash
            # Pull the image
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest
            
            # Run with docker-compose
            docker-compose up -d
            ```
          draft: false
          prerelease: true
          files: |
            coverage.html
            benchmark.out

  # Deploy Phase
  deploy:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    needs: [build, release-latest]
    timeout-minutes: 30
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.12.0

      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace dq-vault-staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Create image pull secret
        run: |
          # Delete existing secret if it exists
          kubectl delete secret regcred --namespace=dq-vault-staging --ignore-not-found=true
          
          # Create new secret
          kubectl create secret docker-registry regcred \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ secrets.DOCKER_USERNAME }} \
            --docker-password=${{ secrets.DOCKER_PASSWORD }} \
            --namespace=dq-vault-staging

      - name: Force clean deployment
        run: |
          # Delete existing deployment to force recreation
          kubectl delete deployment dq-vault-staging --namespace=dq-vault-staging --ignore-not-found=true
          
          # Wait for deployment to be completely removed
          kubectl wait --for=delete deployment/dq-vault-staging --namespace=dq-vault-staging --timeout=300s || true
          
          # Delete existing pods to ensure fresh start
          kubectl delete pods -l app.kubernetes.io/name=dq-vault --namespace=dq-vault-staging --ignore-not-found=true
          
          echo "âœ… Cleaned up existing deployment"

      - name: Deploy with Helm
        run: |
          # Generate unique deployment timestamp for forced updates
          DEPLOY_TIMESTAMP=$(date +%s)
          
          helm upgrade --install dq-vault-staging ./.charts/dq-vault \
            --namespace dq-vault-staging \
            --wait --atomic --timeout=15m \
            --force \
            --values ./.charts/dq-vault/values.yaml \
            --values ./.charts/dq-vault/values-staging.yaml \
            --set image.tag=${{ needs.build.outputs.image-tag }} \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set podAnnotations.deployTimestamp="$DEPLOY_TIMESTAMP" \
            --set podAnnotations.buildId="${{ github.run_id }}" \
            --set podAnnotations.commitSha="${{ github.sha }}"

      - name: Verify deployment
        run: |
          echo "Waiting for deployment to be ready..."
          kubectl wait --for=condition=available --timeout=600s deployment/dq-vault-staging -n dq-vault-staging
          
          echo "Checking pod status..."
          kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault
          
          echo "Checking service status..."
          kubectl get svc -n dq-vault-staging -l app.kubernetes.io/name=dq-vault

      - name: Run health check
        run: |
          echo "Running health check..."
          kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging &
          sleep 15
          
          # Health check with proper parameters for uninitialized Vault
          for i in {1..10}; do
            if curl -s -f "http://localhost:8200/v1/sys/health?standbyok=true&uninitcode=204&sealedcode=204"; then
              echo "âœ… Vault health check passed!"
              break
            else
              echo "Health check attempt $i failed, retrying..."
              sleep 30
            fi
          done
          
          # Additional checks
          echo "Checking Vault initialization status..."
          if curl -s http://localhost:8200/v1/sys/init | grep -q '"initialized":false'; then
            echo "âš ï¸  Vault is not initialized - this is expected for new deployments"
            echo "ðŸ“‹ Next steps: Initialize Vault manually with 'kubectl port-forward' and 'curl' commands"
          elif curl -s http://localhost:8200/v1/sys/init | grep -q '"initialized":true'; then
            echo "âœ… Vault is initialized"
            if curl -s "http://localhost:8200/v1/sys/health" | grep -q '"sealed":true'; then
              echo "ðŸ”’ Vault is sealed - needs to be unsealed with keys"
            else
              echo "ðŸ”“ Vault is unsealed and ready for use"
            fi
          fi
          
          # Cleanup port-forward
          pkill -f "kubectl port-forward" || true

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… DQ Vault staging deployment completed successfully!"
            echo "Release: ${{ github.ref_name }}"
            echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
            echo "Environment: dq-vault-staging"
            echo "Namespace: dq-vault-staging"
          else
            echo "âŒ DQ Vault staging deployment failed!"
            exit 1
          fi

  # Post-deployment verification
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy
    timeout-minutes: 15
    steps:
      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          
          # Test basic connectivity
          kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging &
          sleep 15
          
          # Test Vault health endpoint with proper parameters
          if curl -s -f "http://localhost:8200/v1/sys/health?standbyok=true&uninitcode=204&sealedcode=204"; then
            echo "âœ… Vault health endpoint accessible"
          else
            echo "âŒ Vault health endpoint failed"
            exit 1
          fi
          
          # Test Vault initialization status (should always work)
          if curl -s http://localhost:8200/v1/sys/init | grep -q '"initialized"'; then
            echo "âœ… Vault initialization status check passed"
          else
            echo "âŒ Vault initialization status check failed"
            exit 1
          fi
          
          # Check if pods are ready
          if kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault --no-headers | grep -q "1/1.*Running"; then
            echo "âœ… Pod readiness check passed"
          else
            echo "âŒ Pod readiness check failed"
            kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault
            exit 1
          fi
          
          # Cleanup
          pkill -f "kubectl port-forward" || true
          
          echo "âœ… All smoke tests passed!"

      - name: Check resource usage
        run: |
          echo "Checking resource usage..."
          kubectl top pods -n dq-vault-staging || echo "Metrics not available"
          kubectl get events -n dq-vault-staging --sort-by='.lastTimestamp' | tail -20

      - name: Generate deployment report
        run: |
          echo "## DQ Vault Staging Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "- **Release**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: dq-vault-staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: dq-vault-staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Supported Cryptocurrencies" >> $GITHUB_STEP_SUMMARY
          echo "- Bitcoin (BTC), Ethereum (ETH), Litecoin (LTC)" >> $GITHUB_STEP_SUMMARY
          echo "- Dogecoin (DOGE), Ripple (XRP), Stellar (XLM)" >> $GITHUB_STEP_SUMMARY
          echo "- Solana (SOL), Bitshares (BTS), Tron (TRX)" >> $GITHUB_STEP_SUMMARY

  # Vault Initialization Phase
  vault-init:
    name: Initialize Vault
    runs-on: ubuntu-latest
    needs: verify-deployment
    timeout-minutes: 15
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    steps:
      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Check if Vault is already initialized
        id: vault-status
        run: |
          echo "Checking Vault initialization status..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          echo "Pod name: $POD_NAME"
          
          # Check initialization status
          INIT_STATUS=$(kubectl exec -n dq-vault-staging $POD_NAME -- vault status -format=json | jq -r '.initialized')
          echo "Vault initialized: $INIT_STATUS"
          
          if [ "$INIT_STATUS" = "true" ]; then
            echo "vault-initialized=true" >> $GITHUB_OUTPUT
            echo "âœ… Vault is already initialized"
          else
            echo "vault-initialized=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  Vault is not initialized - will initialize now"
          fi

      - name: Initialize Vault
        id: vault-init
        if: steps.vault-status.outputs.vault-initialized == 'false'
        run: |
          echo "Initializing Vault..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          
          # Initialize Vault and capture output
          INIT_OUTPUT=$(kubectl exec -n dq-vault-staging $POD_NAME -- vault operator init -format=json)
          
          # Parse the JSON output
          UNSEAL_KEYS=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[]')
          ROOT_TOKEN=$(echo "$INIT_OUTPUT" | jq -r '.root_token')
          
          # Store in environment variables (masked for security)
          echo "UNSEAL_KEY_1=$(echo "$UNSEAL_KEYS" | sed -n '1p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_2=$(echo "$UNSEAL_KEYS" | sed -n '2p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_3=$(echo "$UNSEAL_KEYS" | sed -n '3p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_4=$(echo "$UNSEAL_KEYS" | sed -n '4p')" >> $GITHUB_ENV
          echo "UNSEAL_KEY_5=$(echo "$UNSEAL_KEYS" | sed -n '5p')" >> $GITHUB_ENV
          echo "ROOT_TOKEN=$ROOT_TOKEN" >> $GITHUB_ENV
          
          # Mask sensitive values in logs
          echo "::add-mask::$ROOT_TOKEN"
          for key in $(echo "$UNSEAL_KEYS"); do
            echo "::add-mask::$key"
          done
          
          echo "âœ… Vault initialized successfully"
          echo "vault-init-success=true" >> $GITHUB_OUTPUT

      - name: Unseal Vault
        if: steps.vault-init.outputs.vault-init-success == 'true'
        run: |
          echo "Unsealing Vault..."
          
          # Get the pod name
          POD_NAME=$(kubectl get pods -n dq-vault-staging -l app.kubernetes.io/name=dq-vault -o jsonpath='{.items[0].metadata.name}')
          
          # Unseal with first 3 keys
          kubectl exec -n dq-vault-staging $POD_NAME -- vault operator unseal "$UNSEAL_KEY_1"
          kubectl exec -n dq-vault-staging $POD_NAME -- vault operator unseal "$UNSEAL_KEY_2"
          kubectl exec -n dq-vault-staging $POD_NAME -- vault operator unseal "$UNSEAL_KEY_3"
          
          # Verify vault is unsealed
          SEALED_STATUS=$(kubectl exec -n dq-vault-staging $POD_NAME -- vault status -format=json | jq -r '.sealed')
          
          if [ "$SEALED_STATUS" = "false" ]; then
            echo "âœ… Vault unsealed successfully"
          else
            echo "âŒ Failed to unseal Vault"
            exit 1
          fi

      - name: Print Vault credentials
        if: steps.vault-init.outputs.vault-init-success == 'true'
        run: |
          echo "ðŸ” DQ Vault Staging Environment Initialized"
          echo "============================================="
          echo ""
          echo "Environment: dq-vault-staging"
          echo "Release: ${{ github.ref_name }}"
          echo "Timestamp: $(date -u)"
          echo "Status: âœ… Successfully initialized and unsealed"
          echo ""
          echo "ðŸ”‘ UNSEAL KEYS:"
          echo "==============="
          echo "Key 1: $UNSEAL_KEY_1"
          echo "Key 2: $UNSEAL_KEY_2"
          echo "Key 3: $UNSEAL_KEY_3"
          echo "Key 4: $UNSEAL_KEY_4"
          echo "Key 5: $UNSEAL_KEY_5"
          echo ""
          echo "ðŸŽ¯ ROOT TOKEN:"
          echo "=============="
          echo "$ROOT_TOKEN"
          echo ""
          echo "âš ï¸  SECURITY NOTES:"
          echo "==================="
          echo "â€¢ These credentials provide FULL ACCESS to the Vault"
          echo "â€¢ Store them securely and NEVER commit to version control"
          echo "â€¢ Use unseal keys to recover if Vault gets sealed"
          echo "â€¢ Root token should be used only for initial setup"
          echo "â€¢ Create limited tokens for day-to-day operations"
          echo ""
          echo "ðŸš€ NEXT STEPS:"
          echo "=============="
          echo "â€¢ Access Vault: kubectl port-forward svc/dq-vault-staging 8200:8200 -n dq-vault-staging"
          echo "â€¢ Test health: curl http://localhost:8200/v1/sys/health"
          echo "â€¢ Follow setup guide in repository"
          echo ""
          echo "âœ… Vault credentials printed above"

      - name: Vault initialization summary
        if: always()
        run: |
          if [ "${{ steps.vault-status.outputs.vault-initialized }}" = "true" ]; then
            echo "â„¹ï¸  Vault was already initialized - no action needed"
          elif [ "${{ steps.vault-init.outputs.vault-init-success }}" = "true" ]; then
            echo "âœ… Vault initialization completed successfully!"
            echo "ðŸ“‹ Credentials printed in workflow logs"
            echo "ðŸ” Vault is now ready for use"
          else
            echo "âš ï¸  Vault initialization was skipped or failed"
          fi
          
          # Add to GitHub summary
          echo "## Vault Initialization Status" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.vault-status.outputs.vault-initialized }}" = "true" ]; then
            echo "- **Status**: â„¹ï¸ Already initialized" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.vault-init.outputs.vault-init-success }}" = "true" ]; then
            echo "- **Status**: âœ… Successfully initialized" >> $GITHUB_STEP_SUMMARY
            echo "- **Credentials**: ðŸ“‹ Printed in workflow logs" >> $GITHUB_STEP_SUMMARY
            echo "- **Unsealed**: âœ… Ready for use" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status**: âš ï¸ Skipped or failed" >> $GITHUB_STEP_SUMMARY
          fi
